## pytest 特性

## 用例标记 mark
- pytest.ini 注册一个标签
- @pytest.mark.tagname
- pytest -m "tagname"

## 标记整个类
类上面加 @pytest.mark

## 标记的组合
- and  必须同时具备两个标签
- or  只需要满足其中的一个标签，就会运行
- not    "success and not demo"

用例标记的时候，标签如果有逻辑运算，一定要加双引号，

## 断言
pytest的断言可以直接使用的 python 内置的关键字 assert

## 测试报告
pip install pytest-html

> pytest -m "demo and not smoke" --html=report.html

## 使用脚本方式运行 pytest
```python
# pytest.main()
pytest.main(["--html=output.html"])
```


## pytest 用例执行顺序
从上到下

## 数据驱动
```python
# unitest：

@ddt.ddt
class TestClass()....
	@ddt.data(*test_data_list)
	def  test_fangfa（self, test_info）
		pass

# pytest: data_list=[{}, {}, {}]
class TestClass()...
	@pytest.mark.paramatrize("**test_info**", data_list):
	def test_demo(**test_info**):
		pass
```


​    

## 数据驱动注意事项
在使用pytest.mark.paramatrize 做数据驱动的时候，pytest 和 unittest 不兼容：

- 如果使用 pytest 的数据驱动装饰器，测试类不能继承 unittest.TestCase，否则就需要用ddt做数据驱动。同时断言也不能用unitest的断言self.assert，需要使用Python自带的assert
- 如果要使用unittest写用例,  就要用 unittest 的数据驱动ddt

## 测试夹具
- 普通函数

- @pytest.fixture() 声明这是一个测试夹具

- 把 return 改成 yield 实现前置和后置
    - yield 前就是前置
    - yield 后的就是后置
    
- 后置清理语句放在 yield 之后。返回值跟在yield之后

    ```
    # 测试夹具定义
    @pytest.fixture(scope="function")  # 表setUp和tearDown，测试方法、函数前后执行
    # @pytest.fixture(scope="class")  # 表setUpClass、tearDownClass，测试类前后去执行
    # @pytest.fixture(scope="module")  # 模块运行前后执行
    def fixtrue_driver():
        """管理浏览器"""
        # 前置条件:打开浏览器
        from selenium import webdriver
        driver = webdriver.Chrome()
        driver.implicitly_wait(Handler.yaml["selenium"]["wait_time"])
        # driver.implicitly_wait(WAIT_TIME)
        yield driver
    # 后置条件
        driver.quit()
        
    # 测试夹具使用：作为测试方法的形参根据scope值不同，该方法所属类、所属模块会在运行前后执行夹具代码 
    def test_login_error(self, test_info, fixtrue_driver)
    	fixtrue_driver.find.......
    # 存放：所有测试夹具放在conftest.py文件中，pytest调用夹具时会自己从该文件中获取相应代码
    
    ```
    

## -s

捕获所有的输出，print()
如果不加 -s, 输出信息不会显示

```
pytest.main(["--html={}.html".format(ts), "-m demo","-s"])
```

## pytest 有2个功能不能和unittest兼容
- paramatrize

- fixture

- hook

  此外都是兼容的

  

## pytest的测试方法重运行

pytest插件库：http://plugincompat.herokuapp.com

```
安装插件：pip install pytest-rerunfailures
调用：
pytest --reruns 2 --reruns-delay 5
pytest.main(["--reruns","5"])
```



## 逻辑封装
（浏览器操作、页面共用操作、功能业务测试操作）

- 测试代码和   页面操作 分开了。
  - 1. 通用：查找元素：def find(locator) →common包里面
       - 浏览器操作：def browser()→common包里面
  - 2. 业务代码通用操作：def login(username, pwd)→middlewares包里面
    3. 测试代码：def invert()→tests包里面
- PageObjectModel   页面对象模型
  - 登录的操作放在了一个类当中，初始化了 LoginPage 对象。
    - 优点：前端改了登录页面，只需要更改middlewares/pages/login.py这个共用的登录模块即可；
    - 其他业务测试代码（如test_invert.py）是直接调用login.py中的类的，所以不需要做修改。



## pytest的运行参数

```
# cmd运行：
pytest
	--reruns 2 --reruns-delay 5 
	-m error_test11 
	-s 
	--html=ceshi.html

# ide运行：
pytest.main(["--reruns","2","--reruns-delay", "5",
	"-m error_test11", 
	"-s", 
	"--html=ceshi.html"])
```

