## pytest 和 unittest 共用
- unittest 去编写用例
    - ddt
    - setUptearDown
    - self.assertTrue()
    
- pytest 运行用例
    - 自动收集
    - 用例筛选
    - 测试报告
    - 测试插件
    
## pytest 有哪些好处？（你为什么用 pytest, unittest）
“unittest 过时了，pytest 才是王道”？
- unittest是标准库
  - 不需要安装
  - 标准库不存在说和 python 版本不兼容的问题。 
- pytest是三方库
  - 存在更新修复bug不及时，与Python版本不兼容的问题

## PageObject
- PageObject 页面对象（把页面（app页面）封装成对象）。 
- 对象
    - 属性： 元素定位器， URL ， 标题， （DOM对象→python对象）
    - 方法： 元素定位，点击，（做了某个动作，执行了某步操作）
      - 动作：由多个操作组合起来，每个操作可以进一步单独封装成动作，但可能并不必要


## PageObject 原则
- 是不是所有的动作都需要单独封装成页面对象的方法。
    - 你可以封装，但不必要这么做。
    - 遵循的原则：
      - 你用到了什么行为， 你就封装什么行为。
      - 根据需要考虑行为的颗粒度，做好分层：可以重复封装行为，按需使用，但要注意方法间的依赖性进行调用
- 封装的页面操作的返回值
    - 通常返回self，或者是其他的页面对象、某个属性值
        - 如果你需要获取某个元素或者属性，就直接返回元素本身或者属性。
        - 如果一个操作它可能会有多个结果，比如结果是页面跳转或者返还本页面。需要根据结果返还的页面，封装成多个方法（login→login_success，login_fail）：
            - 返回其他页面的好处：不需要在test方法中再初始化其他页面
            - 返回self(本页面)：链式操作

    
## PO模式的好处
- 可维护性：
  - 前端修改了元素属性，可以只维护pageObject而不修改测试逻辑
- 可读性。
  - PO封装函数名或者类名具有注释说明的功能，体现了操作
  - pageObject对象中可以给方法加上注释，说明传参和返回值意义。这些注释在调用方法时可复用
  - 非常复杂的逻辑才需要在po调用层说明注释，不然一般在po定义层做注释
- 扩展性。
  - 有新功能、新需求需要实现，更加方便。已封装的部分可复用
- 可复用性：重复使用。
- 页面操作逻辑和测试操作逻辑的分离
  - po定义层：页面操作的封装：locator
  - po调用层：测试操作：页面操作的有序调用集合

## 测试用例代码的编写
- 1， 初始化要用到的页面页面
- 2， 链式调用有序的页面逻辑操作，目的是获取实际结果
- 3， 断言得到结果

## 数据分组
分组的原因：

- 和接口测试不同，ui测试的步骤繁多且各有区别，每个用例对应的步骤如果不同，数据也会不同，从而需要分组

分组的依据

- 什么情况下需要分组？：用例的测试步骤不一致
  - 一组步骤一组数据
- 可以根据测试用例分类，把数据分组。分组可以通过切片，也可以通过表格直接对原始测试数据通过表单分组。也可以一个模块用一个excel文件分组

保存用例，建议不要通过excel 去管理，可以用py文件或者yaml文件直接准备数据
- py文件：
- yaml文件, 也支持字典的格式，

## locator 分层

- 元组形式的locator用*拆包，字典形式的locator用**拆包
  - driver.find_element(by=By.ID, value=None)

    - driver.find_element(**self.locator)
    - driver.find_element(*self.locator)
- 好处：前端修改元素属性后，只需维护PO定义层的locator
  
    

## web自动化图形化操作：selenium IDE、katalon studio

